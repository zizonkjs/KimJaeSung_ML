# LabelEncoder -> 1,2,3,4...      1D : target용
# OrdinalEncoder -> 1,2,3,4,....  2D : feature에 사용 -> 만족도, 랭킹, DecisionTree 사용시
# OneHotEncoder -> 1이 하나인 패턴 2D : feature에 사용 -> 


1. LabelEncoder
용도: 주로 **목표 변수(Target)**에 사용되어, 카테고리형 데이터를 정수 값으로 변환합니다.
동작 방식: 각 고유한 카테고리 값을 0부터 n-1까지의 정수로 변환합니다. 예를 들어, [apple, orange, banana]는 [0, 1, 2]로 변환됩니다.
장점:
간단하게 카테고리형 데이터를 변환할 수 있습니다.
각 카테고리를 고유한 숫자로 변환하므로 메모리 사용이 적습니다.
단점:
순서가 없는 범주형 변수에 사용하면 모델이 숫자의 서열 관계를 추론하게 되어 잘못된 예측을 할 수 있습니다.
주로 목표 변수에 적합하며, 독립 변수에 사용할 경우 의미가 왜곡될 수 있습니다.

2. OrdinalEncoder
용도: 순서가 있는 범주형 데이터에 사용됩니다.
동작 방식: 고유한 카테고리를 순서가 있는 정수 값으로 변환합니다. 예를 들어, [low, medium, high]를 [0, 1, 2]로 변환합니다.
장점:
순서를 가진 범주형 변수를 모델에 사용할 때 적합합니다.
메모리 사용이 적고, 수치적인 의미를 부여할 수 있습니다.
단점:
순서가 없는 범주형 데이터를 인코딩하면, 모델이 숫자 간의 관계를 잘못 해석할 가능성이 있습니다.
숫자로 변환된 후 순서가 강조되므로, 순서가 중요한 경우에만 사용해야 합니다.

3. OneHotEncoder
용도: 순서가 없는 범주형 데이터를 처리할 때 사용됩니다.
동작 방식: 각 카테고리를 이진 벡터로 변환합니다. 예를 들어, [red, green, blue]는 각각 [1, 0, 0], [0, 1, 0], [0, 0, 1]로 변환됩니다.
장점:
순서가 없는 데이터를 인코딩할 때 의미 왜곡이 없습니다.
각 카테고리가 고유한 벡터로 변환되므로 순서의 개념이 사라집니다.
단점:
고차원 데이터가 생성되어, 카테고리 개수가 많을수록 메모리 사용량이 크게 늘어납니다.
데이터셋에 새로운 카테고리가 등장하면 추가 작업이 필요할 수 있습니다.

요약
LabelEncoder: 주로 목표 변수에 사용되며, 고유한 카테고리를 정수로 변환합니다. 순서가 없는 변수에 사용할 경우 주의가 필요합니다.
OrdinalEncoder: 순서가 있는 범주형 변수를 정수로 변환합니다. 순서가 없는 변수에는 부적합합니다.
OneHotEncoder: 순서가 없는 변수를 처리할 때 가장 많이 사용되며, 카테고리를 이진 벡터로 변환합니다. 하지만 차원이 증가하는 문제가 있을 수 있습니다.

적용 예시
LabelEncoder: 목표 변수로 사용하는 "edible" 또는 "poisonous"와 같은 2진 분류 문제에 적합.
OrdinalEncoder: "small, medium, large"와 같은 순서형 데이터에 적합.
OneHotEncoder: "color"나 "city"처럼 순서가 없는 범주형 데이터에 적합